<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kingbbode | Spring - Open Session In View Pattern</title>
  <meta name="description" content="나는 Spring Jpa의 동작을 잘 이해했을까? 뷰까지 확장되는 영속성 컨텍스트를 이해해보자.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="Spring - Open Session In View Pattern">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://kingbbode.github.io/posts/open-session-in-view">
  <meta property="og:description" content="나는 Spring Jpa의 동작을 잘 이해했을까? 뷰까지 확장되는 영속성 컨텍스트를 이해해보자.">
  <meta property="og:site_name" content="Kingbbode">
  <meta property="og:image" content="https://kingbbode.github.io/assets/og-image.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://kingbbode.github.io/posts/open-session-in-view">
  <meta name="twitter:title" content="Spring - Open Session In View Pattern">
  <meta name="twitter:description" content="나는 Spring Jpa의 동작을 잘 이해했을까? 뷰까지 확장되는 영속성 컨텍스트를 이해해보자.">
  <meta name="twitter:image" content="https://kingbbode.github.io/assets/og-image.jpg">

  <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
  <link href="https://kingbbode.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="Kingbbode Last 10 blog posts" />

  
    <link type="text/css" rel="stylesheet" href="/assets/dark.css">
  
</head>

<body>
  <main role="main">
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav reveal">
  <a href="/" class="header-logo" title="Kingbbode">Kingbbode</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <span class="icon icon-android-person"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://twitter.com/kingbbode" target="_blank" title="Twitter">
          <span class="icon icon-social-twitter"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://www.facebook.com/iwannaknowcoding" target="_blank" title="Facebook">
          <span class="icon icon-social-facebook"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://github.com/kingbbode" target="_blank" title="GitHub">
          <span class="icon icon-social-github"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://dribbble.com/kingbbode" target="_blank" title="Dribbble">
          <span class="icon icon-social-dribbble-outline"></span>
        </a>
      </li>
    
    
    
    
    
      <li>
        <a href="mailto:kingbbode@gmail.com" title="Email">
          <span class="icon icon-at"></span>
        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" target="_blank" title="RSS">
          <span class="icon icon-social-rss"></span>
        </a>
      </li>
    
  </ul>
</nav>

        <article class="article reveal">
          <header class="article-header">
            <h1>Spring - Open Session In View Pattern</h1>
            <p>나는 Spring Jpa의 동작을 잘 이해했을까? 뷰까지 확장되는 영속성 컨텍스트를 이해해보자.</p>
            <div class="article-list-footer">
              <span class="article-list-date">
                January 14, 2017
              </span>
              <span class="article-list-divider">-</span>
              <span class="article-list-minutes">
                
                
                  10 minute read
                
              </span>
              <span class="article-list-divider">-</span>
              <div class="article-list-tags">
                
                  <a href="/tag/spring">spring</a>
                
                  <a href="/tag/boot">boot</a>
                
                  <a href="/tag/jpa">jpa</a>
                
                  <a href="/tag/osiv">osiv</a>
                
                  <a href="/tag/hibernate">hibernate</a>
                
                  <a href="/tag/spring layer">spring layer</a>
                
              </div>
            </div>
          </header>

          <div class="article-content">
            <p>Spring에서 ORM을 사용하여 개발을 하며, <code class="highlighter-rouge">Transaction</code>을 이해할 때 쯔음 닥쳐온 혼란이 있습니다.</p>

<p>지인에게 자신있게 <code class="highlighter-rouge">Transaction</code>을 설명해주기 위해 Spring Boot로 빠르게 어플리케이션을 올렸고</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/member/{memberIdx}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">member</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">Long</span> <span class="n">memberIdx</span><span class="o">,</span> <span class="n">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">memberIdx</span><span class="o">);</span>

    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="n">model</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>

    <span class="k">return</span> <span class="s">"index"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Transaction</code>이 끝난 상태에서 <code class="highlighter-rouge">Team</code>을 조회하니까 <code class="highlighter-rouge">LazyInitializationException</code>이 발생할꺼야!</p>

<p>하는 순간 페이지가 정상적으로 노출되는 당황스러운 순간이,,!</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/hrrrrrr.png" alt="출처:하이버네이트 완벽 가이드" /></p>

<hr />

<p>본 내용은 <a href="http://aeternum.egloos.com/2798098">Open Session In View Pattern</a>의 내용을 기반으로 내용을 정리하였습니다.(본 내용을 이해하는데 <code class="highlighter-rouge">레이어 아키텍쳐</code>를 알면 더 이해가 빠를 수 있습니다.)</p>

<p>이번 포스팅에서는 <code class="highlighter-rouge">Spring Boot</code>에서 <code class="highlighter-rouge">Default</code>로 설정해주고 있는 <code class="highlighter-rouge">Open Session In View Pattern</code>에 대하여 설명해보도록 하겠습니다.</p>

<p>해당 패턴은 객체-관계 매핑(ORM, Object-Relational Mapping)의 사용으로 등장하게 된 패턴이며, 예제를 구성하는데에 JPA(Java Persistence API)의 구현체 프레임워크인 Hibernate를 사용할 것 입니다.</p>

<p>시작 전 <code class="highlighter-rouge">Open Session In View</code>에 대해 미리 정리를 하자면, <code class="highlighter-rouge">Open Session In View</code>는 <code class="highlighter-rouge">영속성 컨텍스트를 뷰 렌더링이 끝나는 시점까지 개방한 상태로 유지하는 것</code>입니다.</p>

<p>아래 내용으로</p>

<ul>
  <li>먼저 몇 가지 알아야 할 내용을 먼저 설명하겠습니다.</li>
  <li>그리고 어떤 이유로 이러한 패턴이 등장하게 되었는지를 예제로 살펴볼 것이고,</li>
  <li>과거에는 어떻게 해결하였는지를 볼 것이며,</li>
  <li>Spring Boot에서는 무엇을 해주고 있는지 알아보겠습니다.</li>
</ul>

<h2 id="영속성-컨텍스트">영속성 컨텍스트</h2>

<p>Hibernate는 도메인 레이어 객체들이 하부의 데이터 저장소와 영속성 메커니즘에 대해 알지 않아도 되는 <code class="highlighter-rouge">투명한 영속성(transparent persistence)</code>을 제공하는 <code class="highlighter-rouge">비침투적인(nonintrusive)</code> 프레임워크입니다.</p>

<p>영속성과 관련된 모든 관심사는 도메인 객체로부터 격리된 채 관리자 객체에 의해 투명하게 처리되는데, 이 관리자 객체의 기능을 담당하는 객체가 Hibernate의 <code class="highlighter-rouge">Session 객체</code>이며, <code class="highlighter-rouge">Session 객체</code>는 <code class="highlighter-rouge">영속성 컨텍스트</code>를 포함합니다.</p>

<p>영속성 컨텍스트를 이해하기 위해서는 <code class="highlighter-rouge">Transaction</code>을 이해해야 합니다. <code class="highlighter-rouge">Transaction</code>는 쪼갤 수 없는 업무처리의 단위로 작업의 원자 단위라고 보면 되며, 영속성 컨텍스트는 <code class="highlighter-rouge">Transaction</code>과 1:1로 연결됩니다.</p>

<p>하나의 <code class="highlighter-rouge">Transaction</code>동안 수정된 객체의 모든 상태는 영속성 컨텍스트 내에 저장되어, <code class="highlighter-rouge">Transaction</code>이 종료될 때 데이터 저장소에 동기화(flushing)됩니다. 따라서 하이버네이트 Session을 하나의 작업 단위 동안 생성 및 조회, 수정, 삭제되는 객체의 상태를 보관하는 일종의 캐시로 간주해도 무방합니다.(실제로 하이버네이트 Session을 “1 차 캐시”라고 부르기도 합니다)</p>

<blockquote>
  <p>MemberService.Java</p>
</blockquote>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveTeam</span><span class="o">(</span><span class="n">Long</span> <span class="n">memberIdx</span><span class="o">,</span> <span class="n">Team</span> <span class="n">team</span><span class="o">){</span>
    <span class="n">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">memberIdx</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">moveTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>위 moveTeam 메서드가 실행될 때 @Transactional 어노테이션에 의해 자동으로 Session이 열리게 됩니다.</p>

<p>조회(findOne)를 통해 가져온 Member 객체는 영속성 콘텍스트에 캐쉬되고, <code class="highlighter-rouge">Transaction</code>동안 Member 객체의 변경 사항이 추적됩니다. 이 때 Member 객체는 영속성으 갖는다고 말합니다.</p>

<p>moveTeam에 의해 영속성을 갖는 Member 객체가 변경된 것을 영속성 컨텍스트가 감지하게 됩니다. <code class="highlighter-rouge">Transaction</code>이 종료되는 시점인 메서드 종료 시점에 영속성 컨텍스트가 캐시하고 있는 객체의 변경 상태를 저장소와 동기화하게 되며, 이때 update 쿼리가 자동으로 실행되게 됩니다.</p>

<h2 id="영속성을-갖는-객체의-상태">영속성을 갖는 객체의 상태</h2>

<p>영속성을 갖는 객체는</p>

<ul>
  <li>Persistence</li>
  <li>Detached</li>
  <li>Transient</li>
  <li>Removed</li>
</ul>

<p>위 4 가지 상태를 가집니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/status.png" alt="출처:하이버네이트 완벽 가이드" /></p>

<p>[출처 : 하이버네이트 완벽 가이드]</p>

<p><strong>Persistence</strong></p>

<p>데이터베이스 식별자(주키)를 가지며 작업 단위 내에서 영속성에 의해 관리되는 상태</p>

<blockquote>
  <p>Transaction 안에서 조회, 저장, 수정 등을 통해 가져온 영속성이 부여된 상태를 Persistence 상태라 하며, Transient 상태의 객체도 강제로 Persistence 상태로 전환시킬 수 있습니다.</p>
</blockquote>

<p><strong>Detached</strong></p>

<p>데이터베이스 식별자를 가지지만 영속성 컨텍스트로부터 분리되어 더 이상 데이터베이스와의 동기화가 보장되지 않는 상태</p>

<blockquote>
  <p>Session.close() 메소드는 Session 을 닫고 영속성 컨텍스트를 포함핚 모든 자원을 반환하며, 관리하에 있는 모든 영속 인스턴스를 Detached 상태로 변경시킵니다. 하이버네이트는 Detached 상태의 객체에 대해서는 변경사항을 추적하지 않으며, 따라서 데이터베이스와의 동기화 또한 수행하지 않습니다.</p>
</blockquote>

<p><strong>Transient</strong></p>

<p>아무 상태도 가지지 않는 상태(무 상태를 정의하기 위한 상태)</p>

<blockquote>
  <p>new 연산자를 사용하여 생성한 객체는 곧바로 Persistence 상태가 되지 않고 Transient 상태를 갖게 됩니다.</p>
</blockquote>

<p><strong>Removed</strong></p>

<p>제거될 상태</p>

<blockquote>
  <p>Transaction이 종료되는 시점에 삭제될 객체는 Removed 상태를 갖습니다.</p>
</blockquote>

<h2 id="지연-로딩lazy-loading">지연 로딩(Lazy Loading)</h2>

<p>Open Session In View Pattern의 등장을 설명하기 앞서 중요한 개념이 <code class="highlighter-rouge">지연 로딩(Lazy Loading)</code>입니다.</p>

<p>그리고 <code class="highlighter-rouge">지연 로딩</code>을 설명하기 앞서 알아야 할 것이 JPA의 <code class="highlighter-rouge">페치 전략</code>과 <code class="highlighter-rouge">프록시</code>의 개념입니다.</p>

<p><strong>페치 전략</strong></p>

<p>페치 전략이란 <strong>쿼리 수행과 관련된 객체와 연관 관계를 맺고 있는 객체나 컬렉션</strong> 을 어느 시점에서 가져올지에 대한 전략 입니다. 즉 데이터베이스에서 데이터를 가져 오는 전략을 정의합니다.</p>

<p>JPA에서 정의하는 전략은 두 가지가 있습니다.</p>

<p><code class="highlighter-rouge">EAGER</code> - 데이터를 즉시 가져오는 전략으로 <code class="highlighter-rouge">즉시 로딩</code>이라고 합니다.</p>

<p><code class="highlighter-rouge">LAZY</code> - 데이터가 처음 액세스 될 때 가져오는 전략으로 <code class="highlighter-rouge">지연 로딩</code>이라고 합니다.</p>

<p>JPA에서는 연관관계의 종류에 따라서 기본으로 갖는 페치 전략을 다르게 가지고 있습니다.</p>

<ul>
  <li>
    <p>즉시로딩(EAGER)</p>

    <ul>
      <li><code class="highlighter-rouge">@ManyToOne</code></li>
      <li><code class="highlighter-rouge">@OneToOne</code></li>
    </ul>
  </li>
  <li>
    <p>지연로딩</p>

    <ul>
      <li><code class="highlighter-rouge">@OneToMany</code></li>
      <li><code class="highlighter-rouge">@ManyToMany</code></li>
    </ul>
  </li>
</ul>

<p><code class="highlighter-rouge">프록시</code> 객체는 주로 연관된 데이터를 <code class="highlighter-rouge">지연로딩</code>할 때 사용됩니다.</p>

<p><strong>프록시</strong></p>

<p><code class="highlighter-rouge">지연 페치</code> 전략에 따라 연관 관계를 맺고 있는 객체와 컬렉션에는 실제 ENTITY 대신 실제 객체처럼 위장한 <code class="highlighter-rouge">프록시(Proxy)</code> 객체가 생성됩니다.</p>

<p>프록시는 실제 객체의 참조를 보관하는데, 실제 클래스를 기반으로 만들어 지므로 실제 객체와 유사합니다. 실제 엔티티의 데이터에 접근할 때 영속성 컨텍스트에 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 객체 생성을 요청하게 됩니다. 이를 <code class="highlighter-rouge">프록시 초기화</code>라 하고 처음 사용될 때 <strong>한번만</strong> 초기화됩니다. 초기화되면 프록시를 통해 실제 엔티티에 접근 가능하게 됩니다.</p>

<p>아래는 1:N 관계를 갖는 Team과 Member입니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/mt_erd.png" alt="M-T-ERD" /></p>

<p>Team 도메인은 Member와 <code class="highlighter-rouge">@OneToMany</code>의 관계를 맺고 있습니다.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="n">Long</span> <span class="n">idx</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">20</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">;</span>
</code></pre>
</div>

<p>JPA의 기본 Select를 통하여 Team을 조회하였을 때, 연관관계를 맺고 있는 members List 객체는 지연페치의 대상이되어, Proxy 객체로 채워질 것 입니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/mt_proxy.png" alt="M-T-ERD" /></p>

<p><code class="highlighter-rouge">@OneToMany</code>의 Default는 LAZY이기 때문에 Team 객체를 통해 Member List를 사용하려고 할 때 <code class="highlighter-rouge">Fetch</code>가 되어 쿼리가 실행되게 됩니다.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">iterator</span><span class="o">()</span>
</code></pre>
</div>

<p><em>getMembers를 통해 객체를 호출해왔을 때가 아닌 내부의 값을 호출할 때 Fetch된다는 것!</em></p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="err">지연</span><span class="n">_</span><span class="err">로딩</span><span class="n">_</span><span class="err">프록시</span><span class="n">_</span><span class="err">테스트</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"teamRepository.findOne(1L)"</span><span class="o">);</span>
    <span class="n">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">teamRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"team.getMembers()"</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"members.iterator()"</span><span class="o">);</span>
    <span class="n">members</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>위와 같은 테스트 코드를 작성해보면 더욱 확실하게 알 수 있습니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/proxy_test.png" alt="프록시 테스트" /></p>

<p>최초 <code class="highlighter-rouge">Team</code> 객체를 호출시 연관관계의 <code class="highlighter-rouge">Member</code>들을 호출하지 않는 지연 로딩이 잘 적용되고 있습니다.</p>

<p><code class="highlighter-rouge">team.getMembers</code> Method로 연관관계 객체를 가져오는 시점이 아닌 <code class="highlighter-rouge">members.iterator</code>를 통해 프록시 객체의 데이터에 접근할 때 프록시 객체의 초기화가 이루어지며 지연 로딩이 성공적으로 동작하는 것을 볼 수 있습니다.</p>

<h2 id="open-session-in-view-pattern의-등장">Open Session In View Pattern의 등장</h2>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/layer.png" alt="레이어 구성" /></p>

<p>일반적인 엔터프라이즈 애플리케이션의 레이어 구성 <br />[출처: Domain-Driven Design]</p>

<p>레이어의 명칭이나 개수는 문헌에 따라 약간의 차이가 있지만 대부분의 애플리케이션은 <code class="highlighter-rouge">사용자 화면을 구성하는 사용자 인터페이스 레이어(User Interface Layer)</code>, <code class="highlighter-rouge">애플리케이션의 제어 흐름을 관리하는 애플리케이션 레이어(Application Layer)</code>, <code class="highlighter-rouge">도메인의 핵심 로직을 포함하는 도메인 레이어(Domain Layer)</code>, <code class="highlighter-rouge">상위 계층을 지원하기 위한 인프라스트럭처 레이어(Infrastructure Layer)</code>로 구성됩니다.</p>

<p>일반적인 엔터프라이즈 애플리케이션의 레이어 구성을 스프링 레이어와 매칭해보자면(개념적으로 다르지만),</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/spring_layer.png" alt="스프링 레이어 구성" /></p>

<ul>
  <li><code class="highlighter-rouge">User Inteface Layer</code>는 <code class="highlighter-rouge">Paresentiation Layer</code></li>
  <li><code class="highlighter-rouge">Application Layer</code>는 <code class="highlighter-rouge">Service Layer</code></li>
  <li><code class="highlighter-rouge">Infrastructure Layer</code>는 <code class="highlighter-rouge">Persistence Layer</code>(<code class="highlighter-rouge">Data access Layer</code>)</li>
</ul>

<p>로 매칭될 수 있습니다.</p>

<p>다음과 같은 원칙에 따라 레이어가 분리되며,</p>

<ul>
  <li>
    <p>모델-뷰 분리(Model-View Separation)[Fowler PEAA, Larman AUP]</p>
  </li>
  <li>
    <p>깔끔하고 얇은 뷰(Clean and Thin View)[Johnson J2EEDD]</p>
  </li>
  <li>
    <p>영속성 분리(PI, Persistence Ignorance)[Nilsson ADDD]</p>
  </li>
  <li>
    <p>도메인 레이어 고립(Domain Layer Isolation)[Evans DDD]</p>
  </li>
</ul>

<p>이 때 <code class="highlighter-rouge">서비스 레이어</code>는 <code class="highlighter-rouge">애플리케이션</code>의 <code class="highlighter-rouge">트랜잭션</code> 경계를 정의하는 역할을 하게 되고, 이로인해 발생하는 문제가 <code class="highlighter-rouge">Open Session In View Pattern</code>을 등장하게 했습니다.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">//Controller</span>
<span class="nd">@GetMapping</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">home</span><span class="o">(</span><span class="n">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"teams"</span><span class="o">,</span> <span class="n">teamService</span><span class="o">.</span><span class="na">findAll</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"home"</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//Service</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Team</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(){</span>
    <span class="k">return</span> <span class="n">teamRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">View Layer</code>에서 연관 객체를 사용하려 할 때 발생하는 <code class="highlighter-rouge">LazyInitializationException</code>!</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">org</span><span class="o">.</span><span class="na">hibernate</span><span class="o">.</span><span class="na">LazyInitializationException</span><span class="o">:</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">lazily</span> <span class="n">initialize</span> <span class="n">a</span> <span class="n">collection</span> <span class="n">of</span> <span class="nl">role:</span> <span class="n">com</span><span class="o">.</span><span class="na">kingbbode</span><span class="o">.</span><span class="na">model</span><span class="o">.</span><span class="na">Team</span><span class="o">.</span><span class="na">members</span><span class="o">,</span> <span class="n">could</span> <span class="n">not</span> <span class="n">initialize</span> <span class="n">proxy</span> <span class="o">-</span> <span class="n">no</span> <span class="n">Session</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Exception</code>이 발생한 이유를 아래 그림으로 살펴보겠습니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/non_osiv.png" alt="Non-OSIV" /></p>

<p><code class="highlighter-rouge">findAll</code> 메서드가 종료될 때 <code class="highlighter-rouge">Transaction</code>이 종료되며, <code class="highlighter-rouge">Transaction</code>의 종료로 <code class="highlighter-rouge">JDBC Connection</code>이 <code class="highlighter-rouge">disconnect</code>되고, <code class="highlighter-rouge">Hibernate Session</code>이 종료되며, 영속 객체는 <code class="highlighter-rouge">Detaced</code> 상태로 변경됩니다. 즉 <code class="highlighter-rouge">Service Layer</code>에서 관리되는 <code class="highlighter-rouge">Transaction</code>이 View Layer로 넘어가면서 종료되었기 때문에 발생하는 문제인 것 입니다.</p>

<p>이 문제는 많은 개발자들에게 불편함을 주게되었고, 문제점을 해결하기 위해서 등장한 방법들이 있습니다.</p>

<h3 id="뷰-렌더링에-필요한-객체-그래프를-모두-로드">뷰 렌더링에 필요한 객체 그래프를 모두 로드</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>뷰에서 필요로 하는 모든 연관 관계의 객체를 `EAGER Fetch`로 설정하거나, Join 쿼리를 작성하는 방법입니다.
</code></pre>
</div>

<p>그러나 REPOSITORY의 재사용성 감소 및 복잡성 증가를 야기하는 방법이며, 뷰와 영속성 관심사의 강한 결합(뷰를 수정하면, 모델도 변경해야 하는)은 관심사의 분리 원칙을 위반하게 됩니다.</p>

<h3 id="pojo-facade-패턴">POJO FACADE 패턴</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>애플리케이션 레이어 안에서 새로운 객체를 통해 프록시를 초기화한 후 사용자 인터페이스로 반한하는 방법입니다.
</code></pre>
</div>

<p>POJO FACADE 패턴은 뷰에 대한 관심사를 애플리케이션 레이어의 흐름 관리와 관련된 관심사와 혼합하는 것 입니다. 비록 SERVICE와 독립된 별도의 Pojo 객체에 프록시 초기화 로직을 위치시킨다고 해도 애플리케이션 레이어 개발시에 렌더링될 뷰에 대한 존재와 렌더링과 관련된 요구사항을 고려해야 합니다.</p>

<p>POJO FACADE 패턴의 가장 적절한 용도는 분산 환경에서 원격 통신을 지원하기 위한 REMOTE FACADE[Fowler PEAA]로 사용하는 것 입니다. 분산 환경이 아닌 단일 JVM 상에서 뷰를 렌더링하기 위한 객체 그래프를 전달하는 경우에는 POJO FACADE 를 사용하는 것을 권하지 않습니다.</p>

<hr />

<p><em>뷰 렌더링에 필요한 객체 그래프를 모두 로드하는 방식은 많은 단점이 존재하며, POJO FACADE 패턴은 분산 환경에 적합하다는 결론입니다. 그리고 등장한 것이 <code class="highlighter-rouge">Open Session In View 패턴</code> 입니다</em></p>

<hr />

<h3 id="open-session-in-view-패턴">Open Session In View 패턴</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>뷰 렌더링 시점에 영속성 컨텍스트가 존재하지 않기 때문에 Detached 객체의 프록시를 초기화할 수 없다면 영속성 컨텍스트를 오픈된 채로 뷰 렌더링 시점까지 유지하자는 것 입니다. 즉, 작업 단위를 요청 시작 시점부터 뷰 렌더링 완료 시점까지로 확장하는 것 입니다.
</code></pre>
</div>

<p><code class="highlighter-rouge">Open Session In View</code> 패턴에 대한 많은 논쟁들이 있었지만, 결론은 <code class="highlighter-rouge">Open Session In View</code> 패턴은 레이어 아키텍처를 해치는 안티패턴이 아니라는 것 입니다.</p>

<p>이 내용에 대한 자세히 알고 싶다면 꼭 참조한 문서를 읽어보시길 바랍니다.</p>

<h4 id="전통적인-open-session-in-view-패턴">전통적인 Open Session In View 패턴</h4>

<p>전통적인 <code class="highlighter-rouge">Open Session In View</code> 패턴은 서블릿 필터 시작 시에 하이버네이트 <code class="highlighter-rouge">Session</code> 을 열고 트랜잭션을 시작합니다.</p>

<p>이후 서블릿 필터는 컨트롤러에 요청을 위임하고 뷰 렌더링이 모두 완료된 후에 트랜잭션을 커밋 또는 롤백합니다. 일반적으로 플러시 모드 기본값인 <code class="highlighter-rouge">FlushMode.AUTO</code> 를 사용하므로 영속성 컨텍스트에서 관리하고 있는 모든 <code class="highlighter-rouge">Persistent</code> 상태의 객체는 뷰의 렌더링이 모두 완료되고 서블릿 필터에서 트랜잭션을 커밋하는 순간 데이터베이스로 플러시됩니다.</p>

<p>또한 <code class="highlighter-rouge">ConnectionReleaseMode</code> 의 기본값인 <code class="highlighter-rouge">AFTER_TRANSACTION</code> 에 따라 JDBC 커넥션의 반환 역시 시점 역시 뷰가 모두 렌더링되고 서블릿 필터 내에서 트랜잭션이 커밋(또는 롤백)되는 시점에 이루어지게 됩니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/servlet_osiv.png" alt="전통적인 OSIV" /></p>

<p>[출처 : <a href="http://aeternum.egloos.com">Eternity’s Chit-Chataeternum</a> - <a href="http://aeternum.egloos.com/2798098">Open Session in View Pattern</a> ]</p>

<p>그러나 서블릿 필터 방식의 <code class="highlighter-rouge">Open Session In View</code> 패턴에는 JDBC 커넥션은 뷰의 렌더링이 모두 완료된 후에야 커넥션 풀로 반환되는 <code class="highlighter-rouge">JDBC 커넥션 보유 시간 증가</code>라는 단점과 , 뷰까지 트랜잭션이 확장될 수 있는 <code class="highlighter-rouge">모호한 트랜잭션 경계</code>라는 큰 단점이 있습니다.</p>

<h4 id="spring의-open-session-in-view-패턴">Spring의 Open Session In View 패턴</h4>

<p>Spring 프레임워크에서는 <code class="highlighter-rouge">FlushMode</code> 와 <code class="highlighter-rouge">ConnectionReleaseMode</code>의 조정을 통해 전통적인 서블릿 필터의 단점을 보완핚 <code class="highlighter-rouge">OpenSessionInViewFilter</code> 와 <code class="highlighter-rouge">OpenSessionInViewInterceptor</code> 를 제공합니다.</p>

<p>두 클래스의 가장 큰 특징은 기존 처럼 뷰에서 지연 로딩을 가능하게 하는 동시에 서비스 레이어에 트랜잭션 경계를 선언할 수 있다는 점 입니다.</p>

<p>서블릿 필터에서 <code class="highlighter-rouge">Session</code>을 오픈하고 트랜잭션을 시작하던 전통적인 방식의 <code class="highlighter-rouge">Open Session In View</code> 패턴과 달리 SpringMVC 에서 제공하는 <code class="highlighter-rouge">OpenSessionInViewFilter</code> 는 필터 내에서 <code class="highlighter-rouge">Session</code>을 오픈하지만 트랜잭션은 시작하지 않습니다.</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/spring_osiv.png" alt="Spring의 OSIV" /></p>

<p>[출처 : <a href="http://aeternum.egloos.com">Eternity’s Chit-Chataeternum</a> - <a href="http://aeternum.egloos.com/2798098">Open Session in View Pattern</a> ]</p>

<p>Stack으로 살펴보면,</p>

<p><img src="../../../../images/2016/2016_12_28_OPEN_SESSION_IN_VIEW/osiv.png" alt="OSIV" /></p>

<p><code class="highlighter-rouge">Transaction</code>이 종료된 후에도 <code class="highlighter-rouge">Controller</code>의 <code class="highlighter-rouge">Session</code>이 <code class="highlighter-rouge">close</code>되지 않았기 때문에, 영속 객체는 <code class="highlighter-rouge">Persistence</code> 상태를 유지할 수 있으며, <code class="highlighter-rouge">Session</code>이 열려있고 <code class="highlighter-rouge">Persistence</code> 상태이기 때문에 프록시 객체에 대한 <code class="highlighter-rouge">Lazy Loading</code>을 수행할 수 있게 됩니다.</p>

<p>또한 <code class="highlighter-rouge">Flush Mode</code>가 <code class="highlighter-rouge">Manual로</code> 변경되었기 때문에, 뷰 단에서의 영속 객체의 상태 변화는 <code class="highlighter-rouge">Flush</code>되지 않고 유지될 수 있습니다.</p>

<p><strong>즉 Open Session In View 패턴을 적용한다면, 이전의 <code class="highlighter-rouge">LazyInitializationException</code> 문제는 발생하지 않게 됩니다.</strong></p>

<h4 id="open-session-in-view-in-spring-boot">Open Session In View In Spring Boot</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>그런데 나는 Boot로 어플리케이션을 올렸을 뿐이고, Open Session In View 패턴을 적용한 적이 없었는데?
</code></pre>
</div>

<p>스프링 Boot <code class="highlighter-rouge">Application.properties</code> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">Docs</a>를 읽어보면, 알 수 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code># JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)

...

spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.

...

</code></pre>
</div>

<p>스프링 Boot에서는 <code class="highlighter-rouge">Open Session In View 패턴</code>을 OpenEntityManagerInViewInterceptor를 통해 default로 지원을 해주고 있습니다.</p>

<p>spring.jpa.open-in-view를 바꿔가며 테스트해본다면 명확하게 알 수 있을 것 입니다.</p>

<p><a href="https://github.com/kingbbode/spring-boot-jpa-osiv">예제 GitHub</a></p>

<hr />

<h3 id="마무리">마무리</h3>

<p><code class="highlighter-rouge">Spring Boot</code>를 사용하면서 Boot가 제공해주는 수많은 자동 설정은 우리에게 많은 편리함을 느끼게 합니다. <strong>그러나 이 편리함 뒤에는 개발자에게 치명적인 함정이 있습니다.</strong></p>

<p><code class="highlighter-rouge">Spring Boot</code>에서 지원해주는 <code class="highlighter-rouge">default</code> 설정들은 사실 이전에는 개발자들이 직접 작성해줘야 했던 설정이기 때문입니다. 저는 서블릿이 등장하고, 프레임워크가 등장하면서 겪었던 함정과 같다고 생각하고 있습니다.</p>

<p><code class="highlighter-rouge">어느 하나도 자동으로 해주는 것은 없다</code>고 생각합니다. 모든 것이 언젠가 누군가 겪었을 불편함을 편하게 만들어준 것일 뿐이지 않을까요?!</p>

<p>모든 것이 대해서 다 알 순 없지만, 적어도 이렇게라도 하나씩 더 많이 알아갈 수 있도록 노력해야겠습니다.</p>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li>
    <p><a href="http://aeternum.egloos.com">Eternity’s Chit-Chataeternum</a> - <a href="http://aeternum.egloos.com/2798098">Open Session in View</a></p>
  </li>
  <li>
    <p>하이버네이트 완벽가이드 : 위키북스</p>
  </li>
  <li>
    <p>Spring 공식 문서 - https://spring.io/docs</p>
  </li>
</ul>

          </div>

          <div class="article-share">
            
            <a href="" title="Share on Twitter" onclick="window.open('https://twitter.com/home?status=Spring - Open Session In View Pattern - https://kingbbode.github.io/posts/open-session-in-view by @kingbbode', 'newwindow', 'width=500, height=225'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x37__stroke"><g id="Twitter"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M128,23.294    c-4.703,2.142-9.767,3.59-15.079,4.237c5.424-3.328,9.587-8.606,11.548-14.892c-5.079,3.082-10.691,5.324-16.687,6.526    c-4.778-5.231-11.608-8.498-19.166-8.498c-14.493,0-26.251,12.057-26.251,26.927c0,2.111,0.225,4.16,0.676,6.133    C41.217,42.601,21.871,31.892,8.91,15.582c-2.261,3.991-3.554,8.621-3.554,13.552c0,9.338,4.636,17.581,11.683,22.412    c-4.297-0.131-8.355-1.356-11.901-3.359v0.331c0,13.051,9.053,23.937,21.074,26.403c-2.201,0.632-4.523,0.948-6.92,0.948    c-1.69,0-3.343-0.162-4.944-0.478c3.343,10.694,13.035,18.483,24.53,18.691c-8.986,7.227-20.315,11.533-32.614,11.533    c-2.119,0-4.215-0.123-6.266-0.37c11.623,7.627,25.432,12.088,40.255,12.088c48.309,0,74.717-41.026,74.717-76.612    c0-1.171-0.023-2.342-0.068-3.49C120.036,33.433,124.491,28.695,128,23.294" fill-rule="evenodd" id="Twitter_1_"/></g></g></svg>
            </a>
            <a href="" title="Share on Facebook" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=https://kingbbode.github.io/posts/open-session-in-view', 'newwindow', 'width=500, height=500'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x31__stroke"><g id="Facebook_1_"><rect fill="none" height="128" width="128"/><path clip-rule="evenodd" d="M68.369,128H7.065C3.162,128,0,124.836,0,120.935    V7.065C0,3.162,3.162,0,7.065,0h113.871C124.837,0,128,3.162,128,7.065v113.87c0,3.902-3.163,7.065-7.064,7.065H88.318V78.431    h16.638l2.491-19.318H88.318V46.78c0-5.593,1.553-9.404,9.573-9.404l10.229-0.004V20.094c-1.769-0.235-7.841-0.761-14.906-0.761    c-14.749,0-24.846,9.003-24.846,25.535v14.246H51.688v19.318h16.681V128z" fill-rule="evenodd" id="Facebook"/></g></g></svg>
            </a>
            <a href="" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=https://kingbbode.github.io/posts/open-session-in-view', 'newwindow', 'width=550, height=400'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" version="1.1" viewBox="0 0 128 128" width="20px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x35__stroke"><g id="Google_Plus"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M40.654,55.935v16.13    c0,0,15.619-0.021,21.979-0.021C59.189,82.5,53.834,88.194,40.654,88.194c-13.338,0-23.748-10.832-23.748-24.194    s10.41-24.194,23.748-24.194c7.052,0,11.607,2.483,15.784,5.944c3.344-3.35,3.065-3.828,11.573-11.877    c-7.222-6.586-16.822-10.6-27.357-10.6C18.201,23.273,0,41.507,0,64c0,22.493,18.201,40.727,40.654,40.727    c33.561,0,41.763-29.275,39.044-48.792H40.654z M113.912,56.742V42.628h-10.063v14.113H89.358v10.081h14.491v14.517h10.063V66.823    H128V56.742H113.912z" fill-rule="evenodd" id="Google_Plus_1_"/></g></g></svg>
            </a>
          </div>

          
        </article>
        <footer class="footer reveal">
  <p>
    <a href="/about" title="About me">Kingbbode</a>
  </p>
</footer>

      </div>
    </div>
  </main>
  <script type="text/javascript" src="/assets/vendor.js"></script>
<script type="text/javascript" src="/assets/application.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
  WebFont.load({
    google: {
      families: ['Cormorant Garamond:700', 'Lato:300,400,700']
    }
  });
</script>


  <script>
    window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
    ga('create','UA-75876601-1','auto');ga('send','pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>


</body>
</html>
